{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cronus","text":"<p>Cronus aims to help you focusing on business logic code only instead of the other glue code.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Cronus contains a list of code generators, which insipred by the Clean Architecture, for Rust, Typescript, OpenAPI, and more.</p> <p>According to one or more configuration files( can be either in YAML (.yml or .yaml) or our DSL(.api) ),  Cronus can generate nice and clean business logic related code and glue code for a bunch of different controller layers(HTTP, GraphQL, etc.) powered by different libraries or frameworks.</p> <p>Cronus <pre><code># More fine-grained configuration can be found at documentation\n\n# For 'rust' generator\nglobal [generator.rust.file = \"src/generated.rs\"]\nglobal [generator.rust.async]\nglobal [generator.rust.async_trait]\n\n# For 'rust_axum' generator\nglobal [generator.rust_axum.file = \"src/generated.rs\"]\n\n\nstruct Todo {\n  id: string\n  content: string\n}\n\nusecase Todo {\n  createTodo {\n      in {\n          content: string\n      }\n\n      out {\n          todo: Todo\n      }\n  }\n}\n</code></pre></p> <p>Cronus can be used to generate the following Business Logic interface code:</p> <p>Generated Rust <pre><code>use serde::{Deserialize, Serialize};\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Todo {\n  pub id: String,\n  pub content: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct CreateTodoRequest {\n  pub content: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct CreateTodoResponse {\n  pub todo: Todo,\n}\n\n#[async_trait]\npub trait TodoUsecase {\n  async  fn create_todo(&amp;self, request: CreateTodoRequest) -&gt; Result&lt;CreateTodoResponse, Box&lt;dyn std::error::Error&gt;&gt;;\n}\n</code></pre></p> <p>Cronus can even step further to generate the following Controller glue code:</p> <p>Generated Rust (Axum) <pre><code>use axum::{\n    extract::State,\n    http::{header, Response, StatusCode},\n    response::IntoResponse,\n    Extension, Json,\n    Router\n};\n\npub async fn create_todo(State(state): State&lt;std::sync::Arc&lt;Usecases&gt;&gt;, Json(request): Json&lt;CreateTodoRequest&gt;) -&gt; Result&lt;impl IntoResponse, (StatusCode, Json&lt;serde_json::Value&gt;)&gt; {\n\n  match state.todo.create_todo(request).await {\n      Ok(res) =&gt; {\n          Ok(Json(res))\n      },\n      Err(err) =&gt; {\n          let mut err_obj = serde_json::Map::new();\n          err_obj.insert(\"message\".to_owned(), serde_json::Value::from(err.to_string()));\n          Err((StatusCode::BAD_REQUEST, Json(serde_json::Value::Object(err_obj))))\n      },\n  }\n}\n\n#[derive(Clone)]\npub struct Usecases {\n  pub todo: std::sync::Arc&lt;dyn TodoUsecase + Send + Sync&gt;,\n}\n\npub fn router_init(usecases: std::sync::Arc&lt;Usecases&gt;) -&gt; Router {\n  Router::new()\n    .route(\"\", axum::routing::post(create_todo))\n    .with_state(usecases)\n}\n</code></pre></p>"},{"location":"#cli-usage","title":"CLI Usage","text":"<pre><code>$ Cronus &lt;your api file&gt;\n# Ex. Cronus main.api\n</code></pre>"},{"location":"#what-is-the-clean-architecture-and-why-we-need-it","title":"What is the Clean Architecture and Why we need it?","text":"<p>The Clean Architecture, tl;dr, proposed by Robert C. Martin, offers several benefits during software development.</p> <ul> <li> <p>Independent of Frameworks:    The architecture does not depend on specific libraries or frameworks, enhancing robustness and flexibility.</p> </li> <li> <p>Testability:    Business rules can be tested independently of UI, database, web server, or other external elements.</p> </li> <li> <p>Independence of UI:    UI can change easily without affecting the business rules, allowing for flexibility in user interface design.</p> </li> <li> <p>Independence of Database:    Business rules are not tied to a specific database, facilitating easy changes in database technologies.</p> </li> <li> <p>Independence from External Agencies:   Business rules remain unaffected by external changes, maintaining their integrity and effectiveness.</p> </li> <li> <p>Manageable Complexity:    Separation of concerns makes the code more manageable and different aspects of the application more understandable.</p> </li> <li> <p>Adaptability to Change:    The architecture is adaptable to changing requirements and technology shifts, thanks to its decoupled nature.</p> </li> <li> <p>Reusability:    Components and business logic can be reused across different parts of the application or in various projects.</p> </li> <li> <p>Scalability:    Decoupled layers allow for independent scalability and parallel development across multiple teams.</p> </li> <li> <p>Maintainability:    The separation of concerns enhances maintainability, simplifying issue resolution and system updates.</p> </li> <li> <p>Clear Business Rules:    Business logic is clear and distinct, making it easier to understand, maintain, and develop further.</p> </li> </ul>"},{"location":"generators/openapi/","title":"OpenAPI","text":"<p>TODO</p>"},{"location":"generators/rust/","title":"Rust Generator","text":"<p>TODO</p>"},{"location":"generators/rust_axum/","title":"Rust Axum Generator","text":"<p>TODO</p>"},{"location":"generators/ts/","title":"typescript","text":"<p>TODO</p>"},{"location":"generators/ts_nestjs/","title":"ts-nestjs","text":"<p>TODO</p>"},{"location":"references/api/","title":"API Format","text":""},{"location":"references/api/#example","title":"Example","text":"<pre><code>global [generator.rust.file = \"src/generated.rs\"]\nglobal [generator.rust_axum.file = \"src/generated.rs\"]\n\nglobal [generator.rust.async]\nglobal [generator.rust.async_trait]\n\n[rest.path = \"hello\"]\nusecase Hello {\n\n  [rest.method = \"post\"]\n  createHello {\n      in {\n          hi: string\n      }\n      out {\n          answer: string\n      }\n  }\n\n  [rest.method = \"get\"]\n  [rest.path = \"item\"]\n  getHello {\n      in {\n          [rest.query]\n          hi: string\n      }\n      out {\n          answer: string\n      }\n  }\n}\n</code></pre>"},{"location":"references/api/#pest-grammer","title":"Pest Grammer","text":"<pre><code>// Basic rules for whitespace and comments\nWHITESPACE = _{ \" \" | \"\\t\" | \"\\r\" | \"\\n\" }\nCOMMENT = _{ \"//\" ~ (!NEWLINE ~ ANY)* }\n\n// Identifiers and basic types\nidentifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | \"_\")* }\ntype_identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | \"_\" | \"[\" | \"]\")* }\npath = @{ (!\"\\n\" ~ ANY)+ }\n\n\n// Import statements\nimport = { \"import\" ~ path }\n\n// Options\noption_value = { integer | string | bool | array  }\ninteger = { ASCII_DIGIT+ }\nstring = { \"\\\"\" ~ (!\"\\\"\" ~ ANY)* ~ \"\\\"\" }\nbool = { \"true\" | \"false\" }\narray = { \"(\" ~ (option_value ~ (\",\" ~ option_value)*)? ~ \")\" }\noption = { \"[\" ~ identifier ~ (\".\" ~ identifier)* ~ (\"=\" ~ option_value)? ~ \"]\" }\n\n\n// Property definitions\nproperty = {     option* ~ identifier ~ optional_property? ~ \":\" ~ type_identifier }\noptional_property = { \"?\" }\n\n\n// Sections for 'in' and 'out' blocks\nin_block = { \"in\" ~ struct_body }\nout_block = { \"out\" ~ struct_body }\n\n// Usecase definitions\nusecase = {\n    option* ~\n    \"usecase\" ~ identifier ~ \"{\" ~\n    method_def* ~\n    \"}\" \n}\n\nmethod_def = {\n  option* ~\n  identifier ~ \"{\" ~\n   in_block? ~\n    out_block? ~\n  \"}\"\n}\n\n// Struct definitions\nstruct_def = { \n    option* ~\n    \"struct\" ~ identifier ~ struct_body\n}\n\nstruct_body = {\n    \"{\" ~\n\n    property* ~\n    \"}\"\n}\n\nglobal_option = {\n    \"global\" ~\n    option\n}\n\n// Root rule\nfile = {\n    SOI ~\n    (usecase | struct_def | import | global_option)* ~\n    EOI\n}\n</code></pre>"},{"location":"references/api/#basic-rules","title":"Basic Rules","text":"<ul> <li>WHITESPACE: Matches any whitespace character including space, tab, carriage return, and newline.</li> <li>COMMENT: Matches comments that start with <code>//</code> and continue until the end of the line.</li> </ul>"},{"location":"references/api/#identifiers-and-basic-types","title":"Identifiers and Basic Types","text":"<ul> <li>identifier: Matches an identifier that starts with an ASCII alphabetic character followed by zero or more alphanumeric characters or underscores.</li> <li>Example: <code>createHello</code></li> <li>type_identifier: Similar to <code>identifier</code>, but can also include square brackets <code>[]</code> to denote array types.</li> <li>Example: <code>string</code></li> <li>path: Matches a path, which is a sequence of any characters except newline.</li> <li>Example: <code>\"src/generated.rs\"</code></li> </ul>"},{"location":"references/api/#import-statements","title":"Import Statements","text":"<ul> <li>import: Matches an import statement, which starts with the keyword <code>import</code> followed by a path.</li> <li>Example: <code>import \"another_file.pest\"</code></li> </ul>"},{"location":"references/api/#options","title":"Options","text":"<ul> <li>option_value: Matches an option value, which can be an integer, string, boolean, or array.</li> <li>Example: <code>\"src/generated.rs\"</code></li> <li>option: Matches an option, which is an identifier followed by an optional value assignment.</li> <li>Example: <code>[generator.rust.file = \"src/generated.rs\"]</code></li> </ul>"},{"location":"references/api/#property-definitions","title":"Property Definitions","text":"<ul> <li>property: Matches a property definition, which consists of optional options, an identifier, an optional question mark for optional properties, and a type identifier separated by a colon.</li> <li>Example: <code>hi: string</code></li> </ul>"},{"location":"references/api/#sections-for-in-and-out-blocks","title":"Sections for 'in' and 'out' Blocks","text":"<ul> <li>in_block: Matches an 'in' block, which starts with the keyword <code>in</code> followed by a struct body.</li> <li>Example:      <pre><code>in {\n    hi: string\n}\n</code></pre></li> <li>out_block: Matches an 'out' block, which starts with the keyword `out' followed by a struct body.</li> <li>Example:      <pre><code>out {\n    answer: string\n}\n</code></pre></li> </ul>"},{"location":"references/api/#usecase-definitions","title":"Usecase Definitions","text":"<ul> <li>usecase: Matches a usecase definition, which consists of optional options, the keyword <code>usecase</code>, an identifier, and a block containing method definitions.</li> <li>Example:      <pre><code>usecase Hello {     \n    createHello {\n        in {\n            hi: string\n        }\n        out {\n            answer: string\n        }\n    }\n}\n</code></pre></li> </ul>"},{"location":"references/api/#method-definitions","title":"Method Definitions","text":"<ul> <li>method_def: Matches a method definition, which consists of optional options, an identifier, and optional 'in' and 'out' blocks enclosed in curly braces.</li> <li>Example:      <pre><code>[rest.method = \"post\"]\ncreateHello {\n    in {\n        hi: string\n    }\n    out {\n        answer: string\n    }\n}\n</code></pre></li> </ul>"},{"location":"references/api/#struct-definitions","title":"Struct Definitions","text":"<ul> <li>struct_def: Matches a struct definition, which consists of optional options, the keyword <code>struct</code>, an identifier, and a struct body.</li> <li>Example:      <pre><code>struct Person {\n    name: string\n    age: integer\n}\n</code></pre></li> </ul>"},{"location":"references/api/#global-options","title":"Global Options","text":"<ul> <li>global_option: Matches a global option, which starts with the keyword <code>global</code> followed by an option.</li> <li>Example: <code>global [generator.rust.file = \"src/generated.rs\"]</code></li> </ul>"},{"location":"references/api/#root-rule","title":"Root Rule","text":"<ul> <li>file: The root rule that matches the entire file, which can contain usecase definitions, struct definitions, import statements, and global options.</li> <li>Example:      <pre><code>global [generator.rust.file = \"src/generated.rs\"]\nusecase Hello {     \n    createHello {\n        in {\n            hi: string\n        }\n        out {\n            answer: string\n        }\n    }\n}\n</code></pre></li> </ul> <p>This updated documentation provides concrete examples for each section of the DSL, illustrating how the grammar can be used to define usecases, structs, and options in a domain-specific language.</p>"},{"location":"references/yaml/","title":"YAML Format","text":"<p>For the users, it is recommended to use API style instead of YAML style to write API spec due to the consideration of readability and convenience.</p> <p>To create a valid YAML file that represents an API specification (<code>RawSpec</code>), you need to follow the structure defined by the Rust structs. Here's a documentation guide on how to define keys and values in the YAML file:</p>"},{"location":"references/yaml/#rawspec","title":"RawSpec","text":"<p>The root structure for the API Spec. It contains the following optional fields:</p> <ul> <li><code>types</code>: A map of type names to <code>RawSchema</code> objects.</li> <li><code>usecases</code>: A map of use case names to <code>RawUsecase</code> objects.</li> <li><code>option</code>: A <code>GlobalOption</code> object with global configuration options.</li> <li><code>imports</code>: A list of strings representing import paths.</li> </ul> <p>Example:</p> <pre><code>types:\n  MyType:\n    type: object\n    properties:\n      id:\n        type: string\n        required: true\nusecases:\n  MyUsecase:\n    methods:\n      myMethod:\n        req:\n          type: object\n          properties:\n            id:\n              type: string\n              required: true\n        res:\n          type: object\n          properties:\n            message:\n              type: string\n              required: true\noption:\n  generator:\n    rust:\n      file: \"output.rs\"\nimports:\n  - \"path/to/another/spec.yaml\"\n</code></pre>"},{"location":"references/yaml/#rawschema","title":"RawSchema","text":"<p>Defines the schema for a type. It has the following optional fields:</p> <ul> <li><code>type</code>: The type of the schema (e.g., \"string\", \"object\").</li> <li><code>items</code>: A <code>RawSchema</code> object for array item types.</li> <li><code>properties</code>: A map of property names to <code>RawSchema</code> objects for object types.</li> <li><code>required</code>: A boolean indicating if the schema is required.</li> <li><code>namespace</code>: A string specifying the namespace for the type.</li> <li><code>enum_items</code>: A list of <code>RawSchemaEnumItem</code> objects for enum types.</li> <li><code>option</code>: A <code>RawSchemaPropertyOption</code> object with additional options.</li> <li><code>extends</code>: A map of strings for extending other schemas.</li> <li><code>flat_extends</code>: A list of strings for flat extending other schemas.</li> </ul>"},{"location":"references/yaml/#rawusecase","title":"RawUsecase","text":"<p>Represents a use case in the API. It contains:</p> <ul> <li><code>methods</code>: A map of method names to <code>RawUsecaseMethod</code> objects.</li> <li><code>option</code>: An optional <code>RawUsecaseOption</code> object with additional options.</li> </ul>"},{"location":"references/yaml/#rawusecasemethod","title":"RawUsecaseMethod","text":"<p>Defines a method in a use case. It has the following optional fields:</p> <ul> <li><code>req</code>: A <code>RawSchema</code> object for the request schema.</li> <li><code>res</code>: A <code>RawSchema</code> object for the response schema.</li> <li><code>option</code>: A <code>RawUsecaseMethodOption</code> object with additional options.</li> </ul>"},{"location":"references/yaml/#globaloption-generatoroption-rustgeneratoroption-etc","title":"GlobalOption, GeneratorOption, RustGeneratorOption, etc.","text":"<p>These structs define various configuration options for the generator. They contain fields that specify file paths, suffixes, and other generator-specific options.</p> <p>When creating your YAML file, you should match the structure and field names defined in these Rust structs. Each key in the YAML file corresponds to a field in the Rust struct, and the value should match the expected type (e.g., string, boolean, object, list).</p>"}]}